

### rebalance (more advanced later)
if balanceOnchain / TotalUpnlOnchain < 0.3
    pionerV1.deposit():
if balanceBroker / TotalUpnlBroker < 0.3
    send telegram notif ( automatisation later)


### Accept Signed Quote Warper
for active OpenQuoteSigned
if (
    verifySelfMaxAcountLeverage(),
    && verifyCounterpartyMaxAccountLeverage(),
    && verifySelfBalance(), // onchain and broker
    && verifyParameters(quoteSigned, config.js),
    && verifyPrice(acceptPrice, brokerPrice, OraclePrice)
    ):
        verifySignQuoteParameters:
        this.warperOpenQuoteDeployOracleAndAcceptQuoteMM():

    
### Accept Close
for active CloseQuoteSigned
    if (verifyPrice(acceptPrice, brokerPrice, OraclePrice)):
        this.warperCloseQuoteSignedAndAcceptClose():


### Settlement and Liquidation
for all open positions where pA == address or pB == address
    if  Upnl >0 , Upnl > IMB *0.8 or if Upnl <0, |Upnl| > IMA or all open bContract where pA == address or pB == address 
        this.wrapperUpdatePriceAndDefault():


### Inventory
{ TSLA : filled : 10, target : 5, quote_target:5, quote_target_open:5}
updateInventory():
    target = sum ( onchain open self OI )
    if not same reajust.

on acceptOpenQuote and acceptCloseQuote -> convert underlying quote_target amount to target

cancelOpenCloseQuoteContractManager():
cancelSignedMessageCloseManager():
cancelOpenQuoteManage():
cancelSignedMessageOpenManager():
on cancelOpenQuote and cancelOpenCloseQuote -> 
    1/ reduce quote_target_open
    2/ if quote_target > quote_target_open
        push acceptOpenQuote and opacceptCloseQuote on enough amount to get (quote_target - quote_target_open) >0

// SignedQuote Storage
    Store signed quote and defined a fill price.
    If canceled or filled delete
    If price reach fill price call acceptQuoteSigned

// Queue of too hedge : We want to know if quote have been accepted and so if we have to react to a cancel.
    // SignedOpenQuote
    // SignedCloseQuote
    // OpenQuote
    // CloseQuote


* PionerV1Open
openQuoteEvent( uint256 indexed bContractId); 
    * getContract(bContractId) -> db
openQuoteSignedEvent( uint256 indexed bContractId,bytes indexed fillAPIEventId); 
    * getContract(bContractId) -> db
cancelSignedMessageOpenEvent(address indexed sender, bytes indexed messageHash);
    * cancelSignedMessageOpenManager()
acceptQuoteEvent( uint256 indexed bContractId); 
    * getContract(bContractId) -> db
cancelOpenQuoteEvent( uint256 indexed bContractId);
    * getContract(bContractId) -> db
    * cancelOpenQuoteManage()

* PionerV1Default
settledEvent(uint256 bContractId);
    * getContract(bContractId) -> db
liquidatedEvent(uint256 bContractId);
    * getContract(bContractId) -> db

* PionerV1Close
openCloseQuoteEvent( uint256 indexed bCloseQuoteId);
    * getCloseQuote(bCloseQuoteId) -> db
acceptCloseQuoteEvent( uint256 indexed bCloseQuoteId);
    * getCloseQuote(bCloseQuoteId) -> db
expirateBContractEvent(uint256 indexed bContractId);
    * getContract(bContractId) -> db
closeMarketEvent( uint256 indexed bCloseQuoteId);
    * getCloseQuote(bCloseQuoteId) -> db
cancelOpenCloseQuoteContractEvent(uint256 indexed bContractId);
    * getCloseQuote(bCloseQuoteId) -> db
    * cancelOpenCloseQuoteContractManager
cancelSignedMessageCloseEvent(address indexed sender, bytes indexed messageHash);
    * cancelSignedMessageCloseManager()

* pionerV1Compliance
    * DepositEvent(address indexed user, uint256 amount);
    * InitiateWithdrawEvent(address indexed user, uint256 amount);
    * WithdrawEvent(address indexed user, uint256 amount);
    * CancelWithdrawEvent(address indexed user, uint256 amount);

pionerV1Oracle
deployBContract(uint256 indexed bOracleId);
    * getOracle(bOracleId) -> db


// Answer RFQ
    config file + price + selfLeverageOnchain + selfLeverageBroker


// config file ( config file per brokers )
    


// transform name to work with twillio/fmp
// verify if the market exist on twillio or fmp

{
        "Side": "Long"
        "Asset": "AAPL",
        "type": "us.stocks",
        "max_leverage": 100,
        "maxLeverageIndividualNotional" : 1000, 
        "imA": 100000000000000000,
        "imB": 100000000000000000,
        "dfA": 15000000000000000,
        "dfB": 15000000000000000,
        "ir": 15000000000000000,
        "expiryA": 30,
        "expiryB": 7776000,
        "timeLockA": 7776000,
        "timeLockB": 7776000,
        "pythPriceFeedID": "0x49f6b65cb1de6b10eaf75e7c03ca029c306d0357e91b5311b175084a5ad55688",
        "maxConfidence": "1000000000000000000",
        "maxDelay": 10,
        "minConfidenceInterval": 0,
        "forceCloseType": 1,
        "tradingViewId": "PYTH:AAPL"
        "kycType": 1,
        "cType": 1,
        "forceCloseType": 1,
        "kycAddress" : "0x0000000000000000000000000000000000000000",
        "step":0.1,
        "brokerMinimalNotional": ,
        "brokerFee":,
    }
    {
        "Asset": "AAPL",
        "type": "us.stocks",
        "maxLeverageIndividualNotional" : 1000, 
        "lowIndividualRequirements" : 1000, 
        "maxSelfCounterpartyRequirements" : ,
    }



GlobalParams : {
        uint256 x;
        uint8 parity;
        address publicOracleAddress;
        uint256 minNotional;
    }



/*
type QueueItem = {
    [asset: string]: {
        [type: string]: {
            [id: string]: {
                amount: number;
                price: number;
                side: boolean;
            };
        };
    };
}

// cancel function to call 

const fillQueue = { // QueueItem

const openQueue  = { // QueueItem
    openContract type only
}

type inventory = {
    [asset: string]: {
        amount: number;
        price: number;
        side: boolean;
    };
}

function cancelOpenOrders(){

    }

function hedgeInventory(){
    
    }

function updatePendingHedgeOrders(){
    // list all pending orders, and last price
    // depending on last price is far and queue urgency high update the queue
    }

1// priorize reducing row with other types in this order of importance.
cancelCloseQuoteContracts
    // pioner.hedger.cancel_all_orders(symbol)
    // verify closeQuote is open
    // openAmount = pioner.hedger.get_open_amount(symbol)
    // openAmount -= cancelAmount
    // if openAmount > 0
        pioner.hedger.add_trade(symbol, openAmount, price, side)
    // assess how  much is filled
cancelOpenQuoteContracts
    // verify position is open
cancelCloseQuoteSigneds
    // verify closeQuote is open
cancelOpenQuoteSigneds
    // verify position is open
closeQuoteContracts
    // verify market is open
    // verify position is open
    // verify other closeQuoteContracts on that id
    // pioner.hedger.add_trade(symbol, volume, price, side)
    // ( kid ) wait for fill

openQuoteContracts
    // verify market is open
    // verify price
    // verify our riks level ( health balance )
    // verify parameters
    // pioner.hedger.add_trade(symbol, volume, price, side)
    // pioner.blockchain.accept_quote()
closeQuoteSigneds
    // verify position is open
    // pioner.hedger.add_trade(symbol, volume, price, side)
    // pioner.blockchain.accept_signed_close_quote()
openQuoteSigneds
    // pioner.hedger.add_trade(symbol, volume, price, side)
    // pioner.client.send_accept_signed_quote()
rfq
    // pioner.hedger.verify_trade_openable(symbol, volume, price)


// define amount of hedge to cancel if not filled


// check if it can fill a trade waiting in the queue
// function to update fill on broker from new queue

function inventoryCheckRoutine(){ // every minutes
    // check contracts state onchain
    // check contract have not been cancelled
    // check amount to hedge, if we have enough inventory
    // check if need to update orders in inventory
}

*/

///////////////////// Inventory
// for each asset, look in config file wich hedger.
// For mt5 case, it can be multiple hedgers with multiple accounts.

// when changing a source, verify no hedges are open, if so close them and open them on new source

// convert pioner symbols to mt5 symbols


// inventory

// inventory.addTrade(trade)
// inventory.removeTrade(trade)
// inventory.getTrade(trade)